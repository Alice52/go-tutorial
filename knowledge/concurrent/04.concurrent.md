## 并发

1. 多个 goroutine 同时操作一个资源就会发生竞态问题
   - 经典的累加问题: **值覆盖**
2. 互斥锁: `sync.Mutex`

   - 多个 goroutine 同时等待一个锁时, 唤醒的策略是随机的

3. 读写互斥锁: `sync.RWMutex`

   - Lock(): 写锁
   - Unlock(): 释放写锁
   - RLock(): 读锁
   - RUnlock():释放读锁

4. 等待组: `sync.WaitGroup`{java-cdl}

   - Add(int)
   - Done()
   - Wait()

5. 并发控制一次: `sync.Once`{java-单例-dcl}

   - `func (o *Once) Do(f func())`
   - sync.Once 其实内部包含一个互斥锁和一个布尔值
   - 互斥锁保证布尔值和数据的安全
   - 而布尔值用来记录初始化是否完成

6. sync.Map

   - 多个 goroutine 操作同一个 Map 线程不安全
   - Store(key, value interface{})
   - Load(key interface{}) (value interface{}, ok bool)
   - Delete(key interface{})
   - **`Range(f func(key, value interface{}) bool)`**: {java-map()}

7. 原子操作

   - pkg: `sync/atomic`
   - sample

     ```go
     // 原子操作版
     type AtomicCounter struct {
       counter int64
     }

     func (a *AtomicCounter) Inc() {
       atomic.AddInt64(&a.counter, 1)
     }

     func (a *AtomicCounter) Load() int64 {
       return atomic.LoadInt64(&a.counter)
     }
     ```
